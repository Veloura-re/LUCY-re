generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String              @id @default(uuid())
  email              String              @unique
  passwordHash       String?
  name               String
  role               Role
  schoolId           String?
  verified           Boolean             @default(false)
  bio                String?
  preferences        Json?               @default("{\"neuralSync\": true, \"analyticExport\": false, \"immersiveVisuals\": true}")
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  // New Fields for Teacher Profile
  teacherCode        String?             @unique
  phone              String?
  qualification      String?
  photoUrl           String?
  attendanceRecords  AttendanceRecord[]
  lockedAttendance   AttendanceRecord[]  @relation("AttendanceLockedBy")
  auditLogs          AuditLog[]
  issuedCertificates Certificate[]
  chatRooms          ChatRoomMember[]
  classesHomeroom    Class[]             @relation("HomeroomTeacher")
  createdEvents      Event[]
  createdExams       Exam[]
  lockedExams        Exam[]              @relation("ExamLockedBy")
  gradeRecords       GradeRecord[]
  authoredNotes      InternalNote[]      @relation("AuthorNotes")
  sentMessages       Message[]           @relation("SentMessages")
  receivedMessages   Message[]           @relation("ReceivedMessages")
  parentLinks        ParentStudentLink[]
  student            Student?
  authoredRemarks    StudentRemark[]     @relation("TeacherRemarks")
  teacherAssignments TeacherAssignment[]
  timetable          Timetable[]
  createdLessons     Lesson[]
  school             School?             @relation(fields: [schoolId], references: [id])
  bookRequests       BookRequest[]
  resourceProgress   ResourceProgress[]
  marklistConfigs    MarklistConfig[]
}

model School {
  id               String       @id @default(uuid())
  name             String
  schoolCode       String       @unique
  domain           String?
  status           SchoolStatus @default(PENDING)
  createdAt        DateTime     @default(now())
  attendanceConfig Json?        @default("{\"type\": \"PERIOD\", \"lockAfterMinutes\": 30, \"enableLateMarking\": true}")
  logoUrl          String?
  address          String?      @db.Text
  chatRooms        ChatRoom[]
  events           Event[]
  grades           Grade[]
  messages         Message[]
  periods          Period[]
  students         Student[]
  subjects         Subject[]
  users            User[]
  feeStructures    FeeStructure[]
  invoices         Invoice[]
  books            Book[]
  bookRequests     BookRequest[]
  unitPacks        UnitPack[]
  marklistConfigs  MarklistConfig[]
}

model Grade {
  id       String    @id @default(uuid())
  schoolId String
  name     String
  level    Int       @default(0)
  classes  Class[]
  school   School    @relation(fields: [schoolId], references: [id])
  students Student[]
  feeStructures FeeStructure[]
  books         Book[]
}

model Class {
  id                 String              @id @default(uuid())
  books              Book[]
  gradeId            String
  name               String
  homeroomTeacherId  String?
  attendanceRecords  AttendanceRecord[]
  grade              Grade               @relation(fields: [gradeId], references: [id])
  homeroomTeacher    User?               @relation("HomeroomTeacher", fields: [homeroomTeacherId], references: [id])
  exams              Exam[]
  messages           Message[]
  periods            Period[]
  students           Student[]
  teacherAssignments TeacherAssignment[]
  timetable          Timetable[]
  lessons            Lesson[]
  marklistConfigs    MarklistConfig[]
}

model Subject {
  id                 String              @id @default(uuid())
  books              Book[]
  schoolId           String
  name               String
  attendanceRecords  AttendanceRecord[]
  exams              Exam[]
  gradeRecords       GradeRecord[]
  school             School              @relation(fields: [schoolId], references: [id])
  teacherAssignments TeacherAssignment[]
  timetable          Timetable[]
  lessons            Lesson[]
  marklistConfigs    MarklistConfig[]
}

model TeacherAssignment {
  id        String  @id @default(uuid())
  teacherId String
  classId   String
  subjectId String
  class     Class   @relation(fields: [classId], references: [id])
  subject   Subject @relation(fields: [subjectId], references: [id])
  teacher   User    @relation(fields: [teacherId], references: [id])
}

model Student {
  id                String              @id @default(uuid())
  schoolId          String
  classId           String?
  gradeId           String
  userId            String?             @unique
  firstName         String
  lastName          String
  email             String?
  studentCode       String              @unique
  dob               DateTime?
  enrollmentStatus  EnrollmentStatus    @default(ACTIVE)

  // New Enhanced Fields
  gender            Gender?
  photoUrl          String?
  address           String?             @db.Text
  guardianName      String?
  guardianPhone     String?
  secondaryPhone    String?
  guardianRelation  String?
  grandfatherName   String?
  attendanceRecords AttendanceRecord[]
  certificates      Certificate[]
  examAttempts      ExamAttempt[]
  gradeRecords      GradeRecord[]
  internalNotes     InternalNote[]
  parentLinks       ParentStudentLink[]
  class             Class?              @relation(fields: [classId], references: [id])
  grade             Grade               @relation(fields: [gradeId], references: [id])
  school            School              @relation(fields: [schoolId], references: [id])
  user              User?               @relation(fields: [userId], references: [id])
  remarks           StudentRemark[]
  invoices          Invoice[]
  marklistEntries   MarklistEntry[]
}

model ParentStudentLink {
  id            String        @id @default(uuid())
  parentId      String
  studentId     String
  verifiedAt    DateTime?
  pairingMethod PairingMethod
  parent        User          @relation(fields: [parentId], references: [id])
  student       Student       @relation(fields: [studentId], references: [id])
}

model Exam {
  id                String             @id @default(uuid())
  classId           String
  subjectId         String
  title             String
  createdById       String
  availableFrom     DateTime?
  dueAt             DateTime?
  duration          Int?
  config            Json?
  questions         Json?
  isLocked          Boolean            @default(false)
  isPublished       Boolean            @default(false)
  lockedAt          DateTime?
  lockedById        String?

  // Enhanced Marklist Fields
  category          ExamCategory       @default(TEST)
  totalMarks        Float              @default(100)
  description       String?            @db.Text
  attendanceRecords AttendanceRecord[]
  class             Class              @relation(fields: [classId], references: [id])
  createdBy         User               @relation(fields: [createdById], references: [id])
  lockedBy          User?              @relation("ExamLockedBy", fields: [lockedById], references: [id])
  subject           Subject            @relation(fields: [subjectId], references: [id])
  attempts          ExamAttempt[]
  gradeRecords      GradeRecord[]
}

model ExamAttempt {
  id          String    @id @default(uuid())
  examId      String
  studentId   String
  startedAt   DateTime?
  submittedAt DateTime?
  score       Decimal?
  answers     Json?
  status      String?
  metadata    Json?
  exam        Exam      @relation(fields: [examId], references: [id])
  student     Student   @relation(fields: [studentId], references: [id])
}

model GradeRecord {
  id          String      @id @default(uuid())
  studentId   String
  subjectId   String
  examId      String?
  score       Float
  createdById String
  createdAt   DateTime    @default(now())
  remark      String?
  status      GradeStatus @default(SUBMITTED)
  createdBy   User        @relation(fields: [createdById], references: [id])
  exam        Exam?       @relation(fields: [examId], references: [id])
  student     Student     @relation(fields: [studentId], references: [id])
  subject     Subject     @relation(fields: [subjectId], references: [id])

  @@unique([studentId, examId])
}

model AttendanceRecord {
  id          String           @id @default(uuid())
  studentId   String
  classId     String
  subjectId   String?
  examId      String?
  date        DateTime
  status      AttendanceStatus
  reason      String?
  isLocked    Boolean          @default(false)
  lockedAt    DateTime?
  lockedById  String?
  createdById String
  createdAt   DateTime         @default(now())
  periodId    String?
  class       Class            @relation(fields: [classId], references: [id])
  createdBy   User             @relation(fields: [createdById], references: [id])
  exam        Exam?            @relation(fields: [examId], references: [id])
  lockedBy    User?            @relation("AttendanceLockedBy", fields: [lockedById], references: [id])
  period      Period?          @relation(fields: [periodId], references: [id])
  student     Student          @relation(fields: [studentId], references: [id])
  subject     Subject?         @relation(fields: [subjectId], references: [id])

  @@index([studentId])
  @@index([classId])
  @@index([examId])
  @@index([date])
  @@unique([studentId, examId]) // Ensure only one attendance record per student per exam
}

model Message {
  id          String   @id @default(uuid())
  chatRoomId  String
  fromUserId  String
  toUserId    String?
  classId     String?
  schoolId    String
  content     String
  attachments Json?
  isPinned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  chatRoom    ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  class       Class?   @relation(fields: [classId], references: [id])
  fromUser    User     @relation("SentMessages", fields: [fromUserId], references: [id])
  school      School   @relation(fields: [schoolId], references: [id])
  toUser      User?    @relation("ReceivedMessages", fields: [toUserId], references: [id])

  @@index([chatRoomId])
  @@index([schoolId])
}

model ChatRoom {
  id        String           @id @default(uuid())
  schoolId  String
  name      String?
  type      ChatRoomType     @default(PRIVATE)
  metadata  Json?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  school    School           @relation(fields: [schoolId], references: [id])
  members   ChatRoomMember[]
  messages  Message[]

  @@index([schoolId])
}

model ChatRoomMember {
  id         String   @id @default(uuid())
  chatRoomId String
  userId     String
  joinedAt   DateTime @default(now())
  lastReadAt DateTime @default(now())
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatRoomId, userId])
  @@index([userId])
}

model Certificate {
  id         String   @id @default(uuid())
  studentId  String
  issuedById String
  type       String
  pdfUrl     String?
  issuedAt   DateTime @default(now())
  issuedBy   User     @relation(fields: [issuedById], references: [id])
  student    Student  @relation(fields: [studentId], references: [id])
}

model Event {
  id          String   @id @default(uuid())
  schoolId    String
  title       String
  description String?
  eventDate   DateTime
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])
  school      School   @relation(fields: [schoolId], references: [id])
}

model AuditLog {
  id           String   @id @default(uuid())
  userId       String
  action       String
  resourceType String
  resourceId   String?
  before       Json?
  after        Json?
  ip           String?
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id])
}

model InviteToken {
  id        String    @id @default(uuid())
  token     String    @unique
  email     String
  role      Role
  schoolId  String?
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
}

model StudentRemark {
  id        String   @id @default(uuid())
  studentId String
  teacherId String
  content   String
  term      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)
  teacher   User     @relation("TeacherRemarks", fields: [teacherId], references: [id])

  @@index([studentId])
}

model InternalNote {
  id        String   @id @default(uuid())
  studentId String
  authorId  String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User     @relation("AuthorNotes", fields: [authorId], references: [id])
  student   Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@index([studentId])
}

model Period {
  id                String             @id @default(uuid())
  schoolId          String
  name              String
  startTime         String
  endTime           String
  isBreak           Boolean            @default(false)
  order             Int                @default(0)
  classId           String?
  attendanceRecords AttendanceRecord[]
  class             Class?             @relation(fields: [classId], references: [id])
  school            School             @relation(fields: [schoolId], references: [id])
  timetables        Timetable[]
  lessons           Lesson[]

  @@index([schoolId])
  @@index([classId])
}

model Timetable {
  id        String    @id @default(uuid())
  classId   String
  subjectId String
  teacherId String
  periodId  String
  dayOfWeek DayOfWeek
  class     Class     @relation(fields: [classId], references: [id])
  period    Period    @relation(fields: [periodId], references: [id])
  subject   Subject   @relation(fields: [subjectId], references: [id])
  teacher   User      @relation(fields: [teacherId], references: [id])

  @@unique([classId, periodId, dayOfWeek])
  @@index([teacherId])
}

enum Role {
  SUPERADMIN
  PRINCIPAL
  TEACHER
  HOMEROOM
  PARENT
  STUDENT
}

enum SchoolStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum EnrollmentStatus {
  ACTIVE
  SUSPENDED
  GRADUATED
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}

enum PairingMethod {
  ADMIN
  CODE
  QR
}

enum ChatRoomType {
  PRIVATE
  GROUP
}

enum DayOfWeek {
  MON
  TUE
  WED
  THU
  FRI
  SAT
  SUN
}

enum GradeStatus {
  SUBMITTED
  PENDING
  REVIEWED
  REMARK_REQUESTED
  REMARKED
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum ExamCategory {
  QUIZ
  TEST
  ASSIGNMENT
  MID_TERM
  FINAL_EXAM
  PROJECT
  OTHER
}

model FeeStructure {
  id          String      @id @default(uuid())
  schoolId    String
  gradeId     String?
  name        String
  amount      Decimal
  category    FeeCategory @default(TUITION)
  description String?
  frequency   FeeFrequency @default(TERM)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  school      School      @relation(fields: [schoolId], references: [id])
  grade       Grade?      @relation(fields: [gradeId], references: [id])
  invoiceItems InvoiceItem[]

  @@index([schoolId])
}

model Invoice {
  id          String        @id @default(uuid())
  studentId   String
  schoolId    String
  amount      Decimal
  dueDate     DateTime
  status      InvoiceStatus @default(PENDING)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  student     Student       @relation(fields: [studentId], references: [id])
  school      School        @relation(fields: [schoolId], references: [id])
  items       InvoiceItem[]
  payments    Payment[]

  @@index([studentId])
  @@index([schoolId])
}

model InvoiceItem {
  id             String        @id @default(uuid())
  invoiceId      String
  feeStructureId String?
  name           String
  amount         Decimal
  description    String?
  
  invoice        Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  feeStructure   FeeStructure? @relation(fields: [feeStructureId], references: [id])
}

model Payment {
  id          String        @id @default(uuid())
  invoiceId   String
  amount      Decimal
  method      PaymentMethod @default(CASH)
  reference   String?
  status      PaymentStatus @default(PENDING)
  createdAt   DateTime      @default(now())
  
  invoice     Invoice       @relation(fields: [invoiceId], references: [id])
}

enum FeeCategory {
  TUITION
  TRANSPORT
  SPORTS
  LIBRARY
  LABORATORY
  ACTIVITIES
  OTHER
}

enum FeeFrequency {
  ONCE
  MONTHLY
  TERM
  ANNUAL
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
  MOBILE_MONEY
  OTHER
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
}

model Lesson {
  id          String   @id @default(uuid())
  classId     String
  subjectId   String
  teacherId   String
  periodId    String?
  date        DateTime @db.Date
  topic       String
  objectives  String?  @db.Text
  materials   Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  class       Class    @relation(fields: [classId], references: [id])
  subject     Subject  @relation(fields: [subjectId], references: [id])
  teacher     User     @relation(fields: [teacherId], references: [id])
  period      Period?  @relation(fields: [periodId], references: [id])

  @@index([classId])
  @@index([date])
  @@index([teacherId])
}

model Book {
  id           String   @id @default(uuid())
  schoolId     String
  gradeId      String
  classId      String   // The specific Class Section
  subjectId    String
  title        String
  fileUrl      String
  author       String?
  academicYear String?
  edition      String?
  description  String?
  
  // Governance & Logic
  expiresAt      DateTime?
  prerequisiteId String?
  teacherNote    String?   @db.Text
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  school       School             @relation(fields: [schoolId], references: [id])
  grade        Grade              @relation(fields: [gradeId], references: [id])
  class        Class              @relation(fields: [classId], references: [id])
  subject      Subject            @relation(fields: [subjectId], references: [id])
  prerequisite Book?              @relation("Prerequisites", fields: [prerequisiteId], references: [id])
  dependents   Book[]             @relation("Prerequisites")
  progress     ResourceProgress[]
  unitPacks    UnitPackResource[]

  @@index([schoolId])
  @@index([classId])
  @@index([subjectId])
}

model BookRequest {
  id        String        @id @default(uuid())
  schoolId  String
  userId    String
  title     String
  subject   String?
  grade     String?
  reason    String?       @db.Text
  status    RequestStatus @default(PENDING)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  school School @relation(fields: [schoolId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@index([schoolId])
  @@index([userId])
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
  FULFILLED
}

model UnitPack {
  id          String   @id @default(uuid())
  schoolId    String
  title       String
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  school    School             @relation(fields: [schoolId], references: [id])
  resources UnitPackResource[]

  @@index([schoolId])
}

model UnitPackResource {
  id         String @id @default(uuid())
  unitPackId String
  bookId     String
  order      Int    @default(0)

  unitPack UnitPack @relation(fields: [unitPackId], references: [id], onDelete: Cascade)
  book     Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([unitPackId])
  @@index([bookId])
}

model ResourceProgress {
  id        String   @id @default(uuid())
  userId    String
  bookId    String
  completed Boolean  @default(false)
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
}

// ==========================================
// DYNAMIC MARKLIST CONFIGURATION
// ==========================================

model MarklistConfig {
  id        String   @id @default(uuid())
  schoolId  String
  classId   String
  subjectId String
  teacherId String? 
  
  isLocked  Boolean  @default(false)
  status    String   @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  
  columns   MarklistColumn[]
  entries   MarklistEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  school    School   @relation(fields: [schoolId], references: [id])
  class     Class    @relation(fields: [classId], references: [id])
  subject   Subject  @relation(fields: [subjectId], references: [id])
  teacher   User?    @relation(fields: [teacherId], references: [id])

  @@unique([classId, subjectId]) 
  @@index([schoolId])
}

model MarklistColumn {
  id             String         @id @default(uuid())
  configId       String
  title          String
  maxMarks       Float
  order          Int            @default(0)
  isOptional     Boolean        @default(false)
  
  config         MarklistConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  marks          MarklistMark[]

  @@index([configId])
}

model MarklistEntry {
  id        String   @id @default(uuid())
  configId  String
  studentId String
  
  // Cached calculations
  total     Float?
  percentage Float?
  grade     String?
  remarks   String?

  config    MarklistConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  student   Student        @relation(fields: [studentId], references: [id])
  marks     MarklistMark[] 

  @@unique([configId, studentId])
}

model MarklistMark {
  id        String   @id @default(uuid())
  entryId   String 
  columnId  String 
  score     Float
  
  entry     MarklistEntry  @relation(fields: [entryId], references: [id], onDelete: Cascade)
  column    MarklistColumn @relation(fields: [columnId], references: [id], onDelete: Cascade)

  @@unique([entryId, columnId])
}
